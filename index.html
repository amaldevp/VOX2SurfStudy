<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mesh Quality Study - Optimized</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    
    <style>
        :root { --primary: #2563eb; --bg: #f8fafc; --text: #1e293b; --card-bg: #ffffff; }
        body { margin: 0; font-family: 'Segoe UI', sans-serif; background: var(--bg); color: var(--text); height: 100vh; display: flex; flex-direction: column; overflow: hidden; }
        
        #overlay { position: fixed; inset: 0; background: #0f172a; z-index: 10000; display: flex; align-items: center; justify-content: center; }
        .modal { background: white; padding: 2.5rem; border-radius: 16px; width: 450px; text-align: center; box-shadow: 0 20px 25px -5px rgba(0,0,0,0.5); }

        .header { background: white; padding: 1rem 2rem; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #e2e8f0; position: relative; }
        #progress-bar-container { position: absolute; top: 0; left: 0; width: 100%; height: 5px; background: #e2e8f0; }
        #progress-bar { height: 100%; background: var(--primary); width: 0%; transition: width 0.4s; }

        #canvas-container { display: flex; flex: 1; padding: 20px; gap: 20px; background: #f1f5f9; position: relative; }
        .mesh-card { flex: 1; background: var(--card-bg); border-radius: 12px; border: 1px solid #e2e8f0; display: flex; flex-direction: column; overflow: hidden; position: relative; }
        .mesh-title { padding: 10px; font-size: 0.8rem; font-weight: 800; text-align: center; background: #f8fafc; color: #64748b; text-transform: uppercase; border-bottom: 1px solid #f1f5f9; z-index: 10; }
        .view-container { flex: 1; width: 100%; cursor: grab; }

        /* The single canvas that covers the background */
        #main-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }

        #ui-container { padding: 20px; background: white; border-top: 1px solid #e2e8f0; text-align: center; }
        .radio-group { display: inline-flex; gap: 20px; margin-bottom: 15px; background: #f1f5f9; padding: 10px 20px; border-radius: 50px; }
        button { padding: 0.8rem 3rem; background: var(--primary); color: white; border: none; border-radius: 8px; font-weight: 700; cursor: pointer; }
        button:disabled { background: #94a3b8; }
    </style>
</head>
<body>

    <div id="overlay">
        <div class="modal">
            <h2 style="color: var(--primary);">Mesh Perceptual Study</h2>
            <input type="number" id="user-age" placeholder="Age" style="width:100%; padding:12px; margin-bottom:15px; border:1px solid #ddd; border-radius:8px;">
            <select id="user-gender" style="width:100%; padding:12px; margin-bottom:25px; border:1px solid #ddd; border-radius:8px;">
                <option value="male">Male</option>
                <option value="female">Female</option>
                <option value="other">Other</option>
            </select>
            <button onclick="startStudy()">Begin Evaluation</button>
        </div>
    </div>

    <div id="progress-bar-container"><div id="progress-bar"></div></div>
    <div class="header">
        <span style="font-weight: 800; color: var(--primary);">Evaluation Portal</span>
        <span id="step-counter">Loading...</span>
    </div>

    <div id="canvas-container">
        <canvas id="main-canvas"></canvas>
        <div class="mesh-card"><div class="mesh-title">Input voxel</div><div id="view1" class="view-container"></div></div>
        <div class="mesh-card"><div class="mesh-title">Option 1</div><div id="view2" class="view-container"></div></div>
        <div class="mesh-card"><div class="mesh-title">Option 2</div><div id="view3" class="view-container"></div></div>
    </div>

    <div id="ui-container">
        <div class="radio-group">
            <label><input type="radio" name="choice" value="1"> Option 1</label>
            <label><input type="radio" name="choice" value="2"> Option 2</label>
            <label><input type="radio" name="choice" value="both"> Both</label>
            <label><input type="radio" name="choice" value="none"> None</label>
        </div><br>
        <button id="submitBtn" onclick="submitData()">Submit Answer</button>
    </div>

    <script>
        const SCRIPT_URL = "YOUR_GOOGLE_SCRIPT_URL"; 
        let allTrials = [], currentIndex = parseInt(localStorage.getItem('study_idx')) || 0;
        let userID = localStorage.getItem('study_userID') || "ID_" + Math.random().toString(36).substr(2, 9);
        
        let renderer, views = [];
        const loader = new THREE.OBJLoader();

        // 1. Setup the Single Renderer and Viewports
        function initGlobalRenderer() {
            const canvas = document.getElementById('main-canvas');
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);

            const viewIds = ['view1', 'view2', 'view3'];
            views = viewIds.map(id => {
                const domElem = document.getElementById(id);
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0xffffff);
                
                const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
                camera.position.z = 4;
                
                const controls = new THREE.OrbitControls(camera, domElem);
                controls.enableDamping = true;

                return { domElem, scene, camera, controls };
            });

            // Sync controls
            views.forEach(v => {
                v.controls.addEventListener('change', () => {
                    views.forEach(other => {
                        if(other !== v) {
                            other.camera.position.copy(v.camera.position);
                            other.camera.quaternion.copy(v.camera.quaternion);
                            other.controls.target.copy(v.controls.target);
                        }
                    });
                });
            });

            requestAnimationFrame(animate);
        }

        function animate() {
            render();
            requestAnimationFrame(animate);
        }

        function render() {
            const canvas = renderer.domElement;
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;

            if (canvas.width !== width || canvas.height !== height) {
                renderer.setSize(width, height, false);
            }

            views.forEach(view => {
                view.controls.update();
                
                // Get the bounding box of the placeholder div
                const rect = view.domElem.getBoundingClientRect();
                const canvasRect = canvas.getBoundingClientRect();

                // Calculate scissor and viewport
                const left = rect.left - canvasRect.left;
                const bottom = canvasRect.bottom - rect.bottom;
                const w = rect.width;
                const h = rect.height;

                renderer.setViewport(left, bottom, w, h);
                renderer.setScissor(left, bottom, w, h);
                renderer.setScissorTest(true);

                view.camera.aspect = w / h;
                view.camera.updateProjectionMatrix();
                renderer.render(view.scene, view.camera);
            });
        }

        // 2. Optimized Mesh Management
        function clearScene(scene) {
            scene.traverse(object => {
                if (!object.isMesh) return;
                object.geometry.dispose();
                if (Array.isArray(object.material)) {
                    object.material.forEach(m => m.dispose());
                } else {
                    object.material.dispose();
                }
            });
            while(scene.children.length > 0) scene.remove(scene.children[0]);
        }

        async function initTrial() {
            if (currentIndex >= allTrials.length) return showFinalScreen();

            const trial = allTrials[currentIndex];
            document.getElementById('step-counter').innerText = `Step ${currentIndex + 1} of ${allTrials.length}`;
            document.getElementById('progress-bar').style.width = (currentIndex / allTrials.length) * 100 + "%";

            const pool = [
                { type: 'SV', url: `sv/${trial.prefix}.obj` },
                { type: trial.method.toUpperCase(), url: `${trial.method}/${trial.prefix}.obj` }
            ].sort(() => Math.random() - 0.5);

            window.currentTrial = {
                prefix: trial.prefix,
                method: trial.method,
                order: [{type: 'VOX', url: `vox/${trial.prefix}.obj`}, pool[0], pool[1]]
            };

            // Load meshes into scenes
            window.currentTrial.order.forEach((data, i) => {
                const view = views[i];
                clearScene(view.scene);
                
                loader.load(data.url, (obj) => {
                    obj.traverse(c => { if(c.isMesh) c.material = new THREE.MeshNormalMaterial({ side: THREE.DoubleSide }); });
                    
                    const box = new THREE.Box3().setFromObject(obj);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    const scale = 2 / Math.max(size.x, size.y, size.z);
                    
                    obj.scale.set(scale, scale, scale);
                    obj.position.sub(center.multiplyScalar(scale));
                    view.scene.add(obj);
                });
            });
        }

        // --- Standard Logic ---
        async function loadData() {
            try {
                const res = await fetch('prefixes.txt');
                const text = await res.text();
                const prefixes = text.split(/[\n,]+/).map(s => s.trim()).filter(p => p);
                const methods = ['ndc', 'nmc', 'nmcl'];
                
                allTrials = [];
                prefixes.forEach(p => methods.forEach(m => allTrials.push({ prefix: p, method: m })));
                allTrials.sort(() => 0.5 - Math.random());

                initGlobalRenderer();

                if (localStorage.getItem('study_profile_filled') === 'true') {
                    document.getElementById('overlay').style.display = 'none';
                    initTrial();
                }
            } catch (e) { console.error(e); }
        }

        function startStudy() {
            const age = document.getElementById('user-age').value;
            if(!age) return alert("Enter age.");
            
            localStorage.setItem('study_userID', userID);
            localStorage.setItem('study_profile_filled', 'true');
            document.getElementById('overlay').style.display = 'none';
            initTrial();
        }

        function submitData() {
            const sel = document.querySelector('input[name="choice"]:checked');
            if(!sel) return alert("Select an option.");
            
            currentIndex++;
            localStorage.setItem('study_idx', currentIndex);
            document.querySelectorAll('input[name="choice"]').forEach(r => r.checked = false);
            initTrial();
        }

        function showFinalScreen() {
            document.body.innerHTML = `<div style="text-align:center; padding-top:20vh;"><h1>Finished!</h1><p>Thank you for your time.</p></div>`;
        }

        loadData();
    </script>
</body>
</html>